What are Hooks in React?

ğŸ‘‰ Hooks are special functions that let you â€œhook intoâ€ React features 
(like state, lifecycle, context, etc.) inside functional components.

ğŸ‘‰ Before Hooks (2018), only class components had state & lifecycle methods.

ğŸ‘‰ Now with Hooks, functional components = full power.

ğŸ‘‰ â€œHooks allow functional components to have state, side effects, and lifecycle methods.â€

Rules of Hooks 

ğŸ‘‰ Only call Hooks at the top level

ğŸ‘‰ Not inside loops, conditions, or nested functions.

ğŸ‘‰ Only call Hooks inside React functional components (or custom Hooks)

Commonly Used Built-in Hooks

1. useState (for state management)

ğŸ‘‰ Lets you add state (variables that React watches 
& re-renders when changed).

ğŸ‘‰ Example: Counter App

import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // initial value = 0

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

2. useEffect (for side effects & lifecycle)

ğŸ‘‰ Used for side effects: 
fetching data, timers, subscriptions, DOM manipulation.

ğŸ‘‰ Acts like componentDidMount, componentDidUpdate, 
componentWillUnmount in class components.

ğŸ‘‰ Example:  useEffect(() => {},[])

ğŸ‘‰ Run on every render

useEffect(() => {
  console.log("Component rendered or updated");
});

ğŸ‘‰ Run only on first mount :

useEffect(() => {
  console.log("Runs only once");
}, []);

ğŸ‘‰ Run when a dependency changes:

useEffect(() => {
  console.log("Count changed:", count);
}, [count]);

3. useContext (for global state sharing)

ğŸ‘‰ Lets you use React Context API without prop drilling.

const ThemeContext = React.createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar() {
  const theme = React.useContext(ThemeContext);
  return <h1>Theme is {theme}</h1>;
}

4. useRef (for referencing DOM or persisting values)

ğŸ‘‰ Holds a mutable reference that doesnâ€™t trigger re-renders.

function InputFocus() {
  const inputRef = React.useRef(null);

  const focusInput = () => {
    inputRef.current.focus(); // direct DOM manipulation
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

5. useReducer (for complex state logic)

ğŸ‘‰ Alternative to useState for more complex state (like Redux-lite).

function reducer(state, action) {
  switch (action.type) {
    case "increment": return { count: state.count + 1 };
    case "decrement": return { count: state.count - 1 };
    default: return state;
  }
}

function Counter() {
  const [state, dispatch] = React.useReducer(reducer, { count: 0 });

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </div>
  );
}

6. useMemo (for performance optimization)

ğŸ‘‰ Memoizes (caches) expensive calculations.

const expensiveValue = useMemo(() => {
  return heavyCalculation(num);
}, [num]);

7. useCallback (for memoizing functions)

ğŸ‘‰ Prevents functions from being re-created on every render.

ğŸ‘‰ Useful when passing functions as props.

const handleClick = useCallback(() => {
  console.log("Clicked");
}, []);

8. useLayoutEffect ğŸ› ï¸

ğŸ‘‰ Similar to useEffect, but runs synchronously after DOM mutations.

ğŸ‘‰ Used when you need to measure DOM before browser paints.

9. useImperativeHandle (Advanced)

ğŸ‘‰ Customizes the ref exposed to parent components.


Custom Hooks

ğŸ‘‰ You can create your own hooks to reuse logic.

ğŸ‘‰ Naming convention: must start with use.

Example:

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width;
}

function App() {
  const width = useWindowWidth();
  return <h1>Window width: {width}</h1>;
}


Why Hooks are Important?

ğŸ‘‰ Simpler than class components.

ğŸ‘‰ Make code more clean, reusable, and readable.

ğŸ‘‰ Power up functional components.

ğŸ‘‰ Industry standard â†’ every modern React app uses Hooks.